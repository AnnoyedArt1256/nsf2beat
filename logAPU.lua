--logs APU register writes to file--advances track number after silence detection--easily record a sound effect NSF in one go!local outfile = "logAPU.csv"local autoRecord = true --for sfx recorded from NSF, press right automatically to go to next tracklocal SILENCE_DETECTION_FRAMES = 80 --move on to next recording after x frames--========================================local regAddr = 0x4000local regSize = 0x18 --adapt regValues table initialization in main loop if you change thislocal regValues = {}local savedRegValues = {}local trackNumber = 0local recording = falselocal recordingFrame = -1local silenceTimer = 0local byteCount = 0local totalByteCount = 0local frameCount = 0local ypos = 0local file = io.open(outfile, "w")function printLine(text)	gui.text(0, ypos, text)	ypos = ypos + 8endfunction onWrite(addr, size, value)	--callback called twice for each write?	--https://sourceforge.net/p/fceultra/bugs/744/		--fceux doesn't supply the value written...	--check which instruction was used to write value	--and read from the corresponding register	pc = memory.getregister("pc")	i3 = memory.readbyte(pc-3)	i2 = memory.readbyte(pc-2)	i1 = memory.readbyte(pc-1)	a = memory.getregister("a")	y = memory.getregister("y")	x = memory.getregister("x")		--option a	--option_a = false	--address = i2 + 256*i1	value = ""		if     ( i3 == 0x8C ) then --[[ STY MM   ]]  value = y	elseif ( i3 == 0x8D ) then --[[ STA MM   ]]  value = a	elseif ( i3 == 0x8E ) then --[[ STX MM   ]]  value = x	elseif ( i3 == 0x99 ) then --[[ STA MM,Y ]]  value = a   --address = address + y	elseif ( i3 == 0x9D ) then --[[ STA MM,X ]]  value = a   --address = address + x	else value = a --assume it's one of the indirect STA ops	end		--option_b = false	--if     ( i2 == 0x81 ) then --[[ STA (M,X) ]]  option_b = true	--elseif ( i2 == 0x91 ) then --[[ STA (M),Y ]]  option_b = true	--end		if value~= "" then		--all the kids know to count from 0, but lua insists		--on being special		r = addr-regAddr+1		--only log changes		--TODO:have to always log writes to certain registers cuz they retrigger something?		regValues[r] = value		savedRegValues[r] = value		oldRegValues[r] = value	end	endfunction onExit()	file:close()endmemory.registerwrite(regAddr, regSize, onWrite)emu.registerexit(onExit)if autoRecord then	emu.softreset()endoldRegValues = {-1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1}--need to keep track of some register statessavedRegValues = {-1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1}while(true) do	--reset writes for next frame	regValues = {-1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1}	emu.frameadvance()		ypos = 8	printLine( string.format("TRACK %d", trackNumber) )	if not recording then		printLine( "  waiting for data..." )	else		printLine( "  recording..." )	end		printLine( string.format("frame %d", frameCount) )	printLine( string.format("bytes %d", byteCount) )	printLine( string.format("bytes total %d", totalByteCount) )	--printLine("reg  value")	ypos = ypos + 8	s = ""		local gotWrites = false	for i=0,regSize-1 do		if regValues[i+1] ~= -1 then			gotWrites = true			break		end	end	if gotWrites then		silenceTimer = 0		if not recording then			file:write( string.format("===TRACK%d\n",trackNumber) )			recording = true			recordingFrame = 0			byteCount = 0		end	else		silenceTimer = silenceTimer + 1		if recording and silenceTimer >= SILENCE_DETECTION_FRAMES then			joypad.set(1, {right=true} )			recording = false			recordingFrame = -1			trackNumber = trackNumber + 1		end	end		--1st frame of recording - channel initializations	--music driver doesn't necessarily set timer high of pulse channels	--make sure it's included	if recordingFrame ~= -1 then		if recordingFrame==0 then			regValues[0x03] = savedRegValues[0x03] --4003			regValues[0x07] = savedRegValues[0x07] --4007		end		recordingFrame = recordingFrame + 1	end		if not recording then		frameCount = 0	else		--recording		for i=0,regSize-1 do			--print to screen			if regValues[i+1] == -1 then				printLine( string.format("%04X   ", regAddr+i) )			else				printLine( string.format("%04X %02X", regAddr+i, regValues[i+1]) )			end			--log to file			if i>0 then				s = s .. ","			end			if regValues[i+1] ~= -1 then				s = s .. string.format("%02X", regValues[i+1])				byteCount = byteCount + 1				totalByteCount = totalByteCount + 1			end		end		s = s .. "\n"		file:write(s)				frameCount = frameCount + 1	end		end